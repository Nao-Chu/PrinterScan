扫描参数：
- 文稿来源：[FB, ADF]
- 分辨率：[75, 150, 300, 600]
// - 纸张类型: []   
- 扫描区域: {[(24e, 24e),(49c, 358)], [(0, 0),(49c, 358)]}
- 色彩模式: [gray, color, bw]
2 * 4 * 3 * 2 = 48
总结：无异常


纸张：
- 文稿来源：[FB, ADF]
- 文稿来源纸张：[无，有]
- 非文稿来源纸张：[无，有]
2 * 2 * 2 = 8
总结:      1. 文稿来源为平板，平板无纸张时。扫描白色图片。
                2. 文稿来源为ADF ，ADF无纸张时。扫描面板纸张。
                3. 若2的情况下平板无纸张，则同1。


取消扫描：
- 从PC侧取消
   - 从首部取消
   - 从中间取消
   - 从尾部取消
- 从面板取消
   - 从首部取消
   - 从中间取消
   - 从尾部取消
总结：无异常


代码存在以下问题点：
1. void sendData(int sockfd,scan_header data)接口封装不合理
- 发送数据失败就输出log直接退出程序？
   - 发送一条微信失败，直接退出，合理？         *

2. 建立tcp连接时，connect()函数需考虑超时 *
3. buffer指针应使用void*                                       *
4. 扫描流程应该在子线程中执行                            *
5. connect应该放在子线程中处理                        *
6. 使用SN2013进行测试
7. 把scan流程相关代码放到scanJob.c                *



SN2013测试:
扫描参数：
- 文稿来源：[FB, ADF]
- 分辨率：[75, 150, 300, 600]
// - 纸张类型: []   
- 扫描区域: {[(24e, 24e),(49c, 358)], [(0, 0),(49c, 358)]}
- 色彩模式: [gray, color, bw]
2 * 4 * 3 * 2 = 48
总结：无gray模式

取消扫描：
- 从PC侧取消
   - 从首部取消
   - 从中间取消
   - 从尾部取消
- 从面板取消
   - 从首部取消
   - 从中间取消
   - 从尾部取消
总结：无异常




bug情况：

#bug1
运行异常：
      setScanJob时出现e_Fail: （data->Flags[2] = 0x01）*

总结：标志域文稿来源设置是AUTO（0x00）
            需要设置为0x01(平板) 或者0x02(ADF) (0x03ADFDouble)

#bug234
取消异常：
-从PC侧取消
      无法完好取消，（线程终止问题,recv问题 ）            *
- 从面板取消         
      取消成功，没法重新扫描（线程没终止)  *

总结：1.PC取消是在ReleaseScanJob之后才退出scanJob子线程。
            很有可能在结束之前，子线程进行recv，导致recv卡死。
            2.PC取消在recv时，第一条收到的可能不是abort消息
            （startJob接受一半的数据）， 导致无法取消成功。
            3.面板取消在ReleaseScanJob之后没有退出子线程，
            导致不能重新扫描。
            所以需要在发送CancelScan之前，退出子线程（pc取消）。
            在ReleaseScanJob之后查看子线程是否还存在，若是则推出（面板取消）。
             收到数据循环判断是否是abort消息（pc取消）。

#bug5
代码逻辑异常：                                            *
      写入数据错误
总结： 每次收到的数据可能不是整个包头（32或者24），导致判断已经可写入数据出错


1. 编程规范
   - 接口封装不合理（每个封装经得起问）
2. log设计